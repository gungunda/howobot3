# Лёшин планировщик домашних заданий

Контекст и правила работы для нового чата

Этот документ — то, что нужно ИИ, чтобы быстро вернуться в контекст проекта «Лёшин планировщик домашних заданий» в новом чате.
Пожалуйста, сохраняй его и кидай в начало новой сессии.

=================================

1. ОБЩЕЕ О ПРОЕКТЕ
   =================================

Проект: «Лёшин планировщик домашних заданий»

Цель: помочь школьнику планировать выполнение домашних заданий и разгружать нагрузку заранее, чтобы не копить всё в последний вечер перед уроком.

Формат: веб-приложение, которое работает:

* как обычная страничка в браузере (локально, через localhost),
* и как Telegram Mini App (встраивается в Telegram WebView, открывается ботом).

Особенности:

* Нет полноценного бэкенда. Приложение — чистый фронтенд.
* Данные (расписание, прогресс по задачам и т.д.) хранятся:

  * локально через localStorage,
  * и / или через Telegram WebApp.CloudStorage (когда оно доступно в вебвью).
* То есть хранение делается через одну абстракцию Storage, а не напрямую в window.localStorage.

Приложение должно работать офлайн (без внешнего сервера), и при этом уметь синхронизироваться в Telegram между устройствами ребёнка за счёт CloudStorage.

=================================
2. ГЛАВНЫЙ UX / ПОВЕДЕНИЕ
=========================

У нас есть три основные вкладки экрана:

1. «День» (dashboard)

   * Это главный экран.
   * Показывает задачи, которые надо сделать к ближайшему сроку.
   * Позволяет отмечать прогресс (плюс/минус 10%), отмечать "сделано", открывать инлайн-редактирование задачи.
   * Показывает статистику: всего минут, сколько уже сделано по минутам, средний % выполнения.
   * Есть блок "Разгрузка", где задачи, которые можно сделать заранее (объяснение ниже).

2. «Календарь»

   * Календарь месяца.
   * Щёлк по дню выбирает этот день и переключает обратно на дашборд для этой даты.

3. «Расписание»

   * Это шаблон по дням недели.
   * Здесь определяется постоянное расписание: какие предметы/задания есть каждый день, сколько минут на них тратится, куда они могут быть «разгружены».
   * Здесь же можно добавлять, редактировать и удалять задания из расписания.

Навигация между вкладками реализована кликами по кнопкам с `data-nav="dashboard" | "calendar" | "schedule"`, и в коде отрабатывается через switchView() в events.js.

---

## 2.1. Что такое "расписание недели" (Schedule)

Schedule — это объект вида:

{
monday:    [ { id, title, minutes, offloadDays: [...], meta? }, ... ],
tuesday:   [ ... ],
...
sunday:    [ ... ]
}

Каждая задача в расписании — это "регулярная" задача, которая по умолчанию ожидается каждую неделю.

Поля задачи расписания:

* id: уникальный ID
* title: "Математика, упр. 5"
* minutes: сколько минут примерно займет
* offloadDays: массив ключей дней недели, например ["tuesday","wednesday"]
  Это означает: задачу можно заранее начать делать во вторник или в среду,
  хотя "основной день готовности" у неё может быть позже.
* meta: служебная информация (может быть null или отсутствовать)

---

## 2.2. Что такое override дня

Override дня — это фотография задач, зафиксированных для КОНКРЕТНОЙ даты (YYYY-MM-DD), включая их прогресс.

Override хранится под ключом формата:
planner.override.YYYY-MM-DD.v1

Структура override:
{
dateKey: "2025-10-27",
tasks: [
{
id: "math1",
title: "Математика, упр. 5",
minutes: 30,
donePercent: 40,
done: false,
offloadDays: null, // В override offloadDays всегда null
meta: { ... }      // доп. служебные поля
}
],
meta: {
createdAt: "...",
updatedAt: "...",
deviceId: "...",
userAction: "toggleDone" | "adjustPercent" | ...
}
}

Важно:

* В override задача становится обычной конкретной задачей этого дня. Там нет больше понятия "она пришла из понедельника", "её можно разнести по вторникам", и т.д. offloadDays в override не храним (всегда null).
* Override создаётся ТОЛЬКО в момент реального редактирования прогресса или задачи (например: клик по +10%, отметили чекбокс "сделано", правка названия).
* Просто просмотр дня НЕ должен автоматически создавать override. Это важно, чтобы не спамить в хранилище "пустыми" днями.

---

## 2.3. Логика "разгрузки" (offload)

Очень важная часть.

Есть понятие "разгрузка" — это когда задание из будущего дня ты делаешь заранее в предыдущие дни, чтобы разгрузить вечер перед уроком.

Пример:

* У тебя есть задача в субботу ("сдать проект по технологии").
* Фактический дедлайн — пятница (то есть к пятнице это должно быть готово).
* Но ты хочешь делать это заранее: во вторник и в среду.
  Тогда в расписании у этой задачи offloadDays будет ["tuesday", "wednesday"].

Как это показывается в интерфейсе:

* Сегодня вторник.
* Ты открываешь "День".
* В блоке "Разгрузка" тебе показываются задачи из будущих дней расписания, для которых вторник входит в их offloadDays.
* Это значит: "сделай это сегодня заранее, чтобы потом было легче".

НО:

* У каждой такой задачи есть свой дедлайн-день. Это НЕ сам день урока, а день до урока.
  Например, если урок в субботу, то дедлайн — пятница.
* Прогресс по такой задаче (проценты выполнения) должен сохраняться именно в override дедлайн-дня, а не в "сегодня".
  То есть, если ты сегодня во вторник сделал 20% субботней задачи, то эти 20% должны сохраниться в override пятницы. Потому что к пятнице задача должна быть готова.

Это поведение мы называем "правило D / D+1":

* D+1 (например суббота) — это день занятия/сдачи/урока.
* D (например пятница) — это реальный крайний срок готовности.
* Разгрузка разрешает делать задачу ещё раньше — вторник, среда...
* Но прогресс живёт в D (пятница), а не в "сегодня".

В коде это решается так:

* У каждой задачи в блоке "Разгрузка" мы заранее вычисляем её `deadlineWeekday` (это предыдущий день относительно основного дня из расписания).
* Когда ты жмёшь +10%, мы не создаём override "сегодня". Мы создаём override в ближайшую по календарю дату, которая соответствует `deadlineWeekday`, и правим там прогресс.

---

## 2.4. Поведение при редактировании задачи из "Разгрузка"

Если пользователь нажал ✎ (редактировать) на задаче из блока "Разгрузка" на дашборде:

* Не надо давать ему взять и редактировать поля (название, минуты) прямо тут.
* Вместо этого мы показываем в этой строке специальную "плашку" вместо формы:
  сообщение вида "Это задача из блока 'Разгрузка'. Чтобы изменить её, перейди в расписание недели или в день дедлайна этой задачи".
* То есть не появляется инлайн-форма редактирования, как для обычной задачи дня.
* И не нужно показывать window.alert — мы это не используем. Визуально это просто встроенный блок в списке.

=================================
3. ТЕКУЩАЯ АРХИТЕКТУРА ФРОНТЕНДА
================================

Структура проекта (ключевые файлы):

index.html

* Корневой HTML.
* В нём есть контейнеры для трёх "вкладок":

  * data-view="dashboard"
  * data-view="calendar"
  * data-view="schedule"
* index.html подключает главный JS как ES-модуль.

css / styles.css

* Стили карточек, кнопок, календаря, расписания недели и т.д.
* В процессе миграций копились дубли классов.
* Мы стараемся не плодить новые классы без необходимости.

js/app.js

* Точка входа.
* Делает `await Storage.init()` до любых обращений к repo.
  Это критично, иначе Storage остаётся в "cloud_probe" и не пишет данные.
* После инициализации вызывает initUI() из events.js.

js/infra/telegramEnv.js

* Абстракция над хранилищем.
* Экспортирует объект Storage с методами:

  * Storage.init()
  * Storage.getItem(key)
  * Storage.setItem(key, value)
  * Storage.getKeys()
  * Storage.getMode()
* Внутри определяет режим:

  * "cloud" — используем Telegram.WebApp.CloudStorage
  * "local" — используем localStorage
  * "cloud_probe" — начальное состояние до init()
* init():

  * Проверяет версию Telegram WebApp.
  * Если CloudStorage недоступен (например версия 6.0), логирует `[Storage.init] ... fallback to local` и выставляет режим "local".
  * В браузере вне Telegram тоже уходим в "local".
* В итоге весь код выше уровнем вообще не знает, где он запущен (локально или в Telegram).

ВАЖНО:
Storage.init() ДОЛЖЕН быть вызван ровно один раз в начале (в app.js), ДО первых вызовов repo.js.

js/data/repo.js

* Репозиторий данных (основной источник правды для всего приложения).
* Работает только через Storage.*. Он сам не лезет в localStorage напрямую.
* Умеет:

  * loadSchedule()
  * saveSchedule(scheduleObj)
  * loadDayOverride(dateKey)
  * saveDayOverride(overrideObj)
  * listOverrideDates()
* Умеет готовить модель для дашборда:

  * buildDashboardViewModel(dateKey) (либо сейчас аналогичная логика собрана в events.js и repo поддерживает методы для inline edit)
* Также хранит состояние инлайн-редактирования задач дня:

  * startInlineEditTaskForDate(dateKey, taskId)
  * finishInlineEditTaskForDate(dateKey)
  * getInlineEditStateForDate(dateKey)

То есть repo.js = слой данных + интерфейс к ним, плюс локальное состояние редактирования.

usecases/

* В этой папке — "сценарии действия пользователя".
* Это бизнес-логика (application layer).
* UI вызывает их, они работают через repo.
* Важные файлы:

  * toggleTaskDoneForDate.js (ставит / снимает done, то есть 0% <-> 100%)
  * adjustTaskPercentForDate.js (+10/-10% прогресса)
  * editTaskInline.js (менять название и минуты для конкретной задачи дня)
  * resetToSchedule.js (удалить override и пересобрать день заново)
  * addTaskToSchedule.js / editTaskInSchedule.js / deleteTaskFromSchedule.js (работа с недельным расписанием)

js/ui/events.js

* Главный контроллер интерфейса.
* Держит состояние `state`:
  state = {
  activeView: "dashboard" | "calendar" | "schedule",
  selectedDateKey: "YYYY-MM-DD",
  scheduleEdit: { ... } | null
  }
* Отвечает за:

  * инициализацию UI (initUI()),
  * вешает глобальный обработчик кликов (document.addEventListener("click", ...)),
  * переключение вкладок (switchView),
  * обновление каждой вкладки (refreshDashboard, refreshCalendar, refreshScheduleEditor),
  * обработку действий пользователя на дашборде:

    * клик по чекбоксу done,
    * клик +10/-10,
    * клик ✎ и сохранение инлайн-редактирования,
  * обработку действий по расписанию:

    * "+ Добавить задачу" в дне,
    * "✎" редактировать,
    * "🗑" удалить,
    * "Сохранить"/"Отмена".

Очень важные куски логики в events.js:

* resolveEffectiveDateForTask(rowEl)
  Определяет, в какой ДАТЕ хранить прогресс задачи.
  Обычная задача: прогресс хранится в выбранном дне (state.selectedDateKey).
  Задача из "Разгрузка": прогресс хранится в override дня-дедлайна (например пятницы), который мы находим через ближайшую дату с таким weekday.
* handleInlineEditStart():
  Если задача обычная → показать форму редактирования.
  Если задача из "Разгрузка" → показать плашку с текстом (без формы, без alert).
  Важно: визуальное состояние редактирования привязывается всегда к ТЕКУЩЕМУ отображаемому дню (state.selectedDateKey), чтобы view-dashboard мог отрисовать нужную строку в состоянии "editing".

js/ui/view-dashboard.js

* Генерирует HTML для дашборда (вкладка "День").
* Входная модель (viewModel):
  {
  dateKey: "2025-10-27",
  tasks: [...],          // обычные задачи дня / "на завтра"
  offloadTasks: [...],   // задачи из будущего, которые можно сделать заранее
  stats: { totalMinutes, doneMinutes, doneAvg },
  dashboardEdit: { taskId, ... } | null
  }
* Рендерит:

  * блок "Сегодня / К дате ...",
  * список задач с прогрессом и кнопками,
  * блок "Разгрузка",
  * статистику,
  * inline-форму редактирования для одной выбранной задачи
    ИЛИ плашку "Это задача из разгрузки, отредактируй её в расписании".

js/ui/view-calendar.js

* Генерирует HTML для календаря месяца.
* Календарь должен:

  * подсвечивать выбранный день,
  * подсвечивать сегодня,
  * уметь кликаться.
* Состояние календаря (текущий год/месяц, выбранная дата) управляется через events.js.

js/ui/view-schedule.js

* Генерирует вкладку "Расписание недели".
* Дни недели в порядке Пн..Вс.
* В каждом дне:

  * список задач,
  * кнопки ✎ / 🗑,
  * кнопка "+ Добавить задачу".
* Если задача редактируется:

  * показывается инлайн-форма редактирования: инпут названия, инпут минут, чекбоксы разгрузки.
  * чекбоксы разгрузки:
    • список дней (Пн, Вт, Ср,...)
    • ВАЖНО: день дедлайна (предыдущий день недели относительно дня задачи) всегда disabled.
    Например:

    * если задача стоит в "tuesday", дедлайн — "monday", и "monday" будет disabled.
    * если задача стоит в "monday", дедлайн — "sunday", и "sunday" будет disabled.

Эта логика дисейбла чекбокса — последний исправленный баг, и она сейчас работает корректно.

=================================
4. ВАЖНАЯ ТЕХНИЧЕСКАЯ ЛОГИКА
============================

4.1. Storage.init()

* Должен вызываться в app.js до любых обращений к repo.
* После init() Storage знает, какой режим использовать ("cloud" или "local").
* Если Telegram.WebApp.CloudStorage недоступен (например WebApp версия 6.0), Storage падает обратно в localStorage.
* Без Storage.init() прогресс задач не сохраняется.

4.2. override создаётся не сразу

* Просто открытие дня не создаёт override.
* override создаётся ТОЛЬКО если пользователь меняет данные (делает +10%, ставит done, правит текст).
* Это критично, чтобы не заспамить хранилище "пустыми снимками".

4.3. Разгрузка (offloadTasks)

* Прогресс задач разгрузки сохраняется не в "сегодня", а в дне-дедлайне.
* Когда мы заново строим модель дашборда, мы подтягиваем фактический прогресс этих задач из override дедлайн-дня и показываем этот прогресс прямо в блоке "Разгрузка", чтобы проценты были не всегда "0%".

4.4. Редактирование задачи из "Разгрузка"

* При клике ✎ по задаче из "Разгрузка" не показываем форму редактирования.
* Вместо этого дашборд показывает плашку с сообщением ("Редактировать это можно не здесь…").
* Это делается без alert() — просто через view-dashboard.js.
* Это состояние редактирования записывается в repo.startInlineEditTaskForDate(state.selectedDateKey, taskId), чтобы view-dashboard понял, какую задачу выделить.

4.5. Расписание недели — чекбоксы разгрузки

* В форме редактирования задачи расписания мы показываем чекбоксы по всем дням недели.
* Дедлайн-день (предыдущий день недели) — disabled. Это последний фикс.
* Раньше было неправильно: disabled стоял на текущем дне, а не на предыдущем. Это мы исправили.

=================================
5. КАК МЫ РАБОТАЕМ МЕЖДУ СОБОЙ
==============================

Это ключевой момент. Это рабочий протокол.

5.1. Обмен кодом
Мы не можем полагаться на то, что ИИ "помнит" код между сессиями или может читать твой GitHub сам.
Поэтому у нас 2 направления обмена:

* Ты → ИИ:
  Ты присылаешь текстовый "bundle" проекта или отдельных файлов.
  Формат bundle:
  В начале идёт список файлов (FILE_INDEX_START ... FILE_INDEX_END), потом каждый файл полностью с префиксом `// /путь/к/файлу`.
  Либо ты можешь просто прислать список путей, например:
  index.html
  css/styles.css
  js/ui/view-schedule.js
  и потом по каждому пути прислать полный контент файла.

  Важно: мы работаем только с теми файлами, которые ты явно прислал.
  Если файла нет в бандле/списке — я не должен делать предположения о его содержимом.

* ИИ → Ты:
  Я не даю "кусочки" кода и не прошу "вставь это куда-то сам".
  Я отдаю патч в формате patch.txt, с полным содержимым КАЖДОГО изменённого файла.

  Формат patch.txt:

  ===FILE_START===
  PATH: js/ui/events.js
  -----8<-----
  // полный КОД файла целиком, уже обновлённый
  -----8<-----
  ===FILE_END===

  Потом ты кидаешь этот текст в patch.txt, запускаешь свой apply-patch.cmd, и он сам раскладывает файлы по путям.

  Это важно, чтобы не было рассинхрона (когда где-то в середине файла осталась старая версия логики).

5.2. Наши роли

* Ты — реальный владелец проекта, у тебя "живая" копия.
* Я — инструмент, который помогает рефакторить, чинить баги, улучшать архитектуру, но:

  * я не имею непрерывного доступа к твоему репозиторию;
  * я не помню предыдущее состояние файлов между чатами, если ты не пришлёшь;
  * я не могу проверить твой UI глазами, кроме того как ты опишешь/пришлёшь логи.

Поэтому отладка всегда делается циклами:

1. ты применяешь patch.txt,
2. ты запускаешь у себя,
3. ты присылаешь логи консоли (console.log, ошибки),
4. я делаю следующий patch.txt.

5.3. Правило про тестирование

* После любого изменения мы смотрим консоль (Chrome DevTools -> Console).
* Если там SyntaxError или Uncaught TypeError, присылай это сразу. Мы всегда читаем стек ошибок.

=================================
6. СТАНДАРТЫ ДЛЯ КОДА И ОБЪЯСНЕНИЙ
==================================

Проект "Лёшин планировщик" сделан для начинающего разработчика (junior / студент).

Требования к стилю кода и объяснений:

* Писать спокойно, наставнически. Можно обращаться на "ты".
* Термины сразу объяснять простыми словами.
  Например: "асинхронная функция — это функция, которая не блокирует весь остальной код во время ожидания ответа".
* Код писать максимально читабельно:

  * переносить аргументы по строкам,
  * ставить короткие комментарии "что делает этот шаг",
  * избегать магии без пояснения.
* Без ненужной перегрузки теорией.
  Если тема сложная — даём базовое объяснение и говорим "про это можно подробнее позже".
* Мы фиксируем уверенность разработчика:
  "это нормальная сложность на твоём уровне", "ты всё делаешь правильно по шагам".
* В объяснениях идти по шагам:

  1. что делает строка,
  2. зачем она нужна,
  3. как она работает.

=================================
7. НОВОЕ ПРАВИЛО (ОЧЕНЬ ВАЖНО!)
===============================

Это критическая договорённость, которую нужно всегда учитывать при любой дальнейшей работе.

Правило "НЕ МЕНЯТЬ БЕЗ ЗАПРОСА":

1. ИИ не должен в одностороннем порядке "улучшать" код, который не был напрямую затронут вопросом пользователя.

   * Никаких "я тут заодно переписал половину файла, потому что так красивее".
   * Никаких "я подчищу комментарии".
   * Никаких скрытых архитектурных миграций.

2. Если я (ИИ) считаю, что в другом месте надо сделать рефакторинг, переименование, перенос логики, вынести константу, объединить функции и т.д.:

   * я обязан сначала явно ПРЕДЛОЖИТЬ это текстом,
   * объяснить, зачем,
   * дождаться твоего явного "да, делаем".

   Только после этого я могу прислать patch.txt.

3. В противном случае я меняю только то, о чём прямо попросил пользователь.
   Это значит:

   * если ты сказал "почини дизейбл чекбокса", я правлю только это условие и вспомогательную функцию, и не трогаю всё остальное.
   * я НЕ переписываю целиком файл "для красоты", если ты этого не просил.

4. Мы не добавляем новые вспомогательные слои, модули, константы и т.д. без твоего разрешения.
   Пример нарушения, которого мы хотим избегать:

   * "я внёс WEEKDAY_NAMES_RU_SHORT прямо в файл, чтобы было удобнее" без запроса.
   * "я удалил импорт и сделал новый паттерн экспорта" без запроса.

5. Это правило ещё и про чистоту репозитория:

   * нельзя плодить альтернативные версии логики (типа в одном месте `weekdayNamesRuShort`, в другом `WEEKDAY_NAMES_RU_SHORT`),
   * нельзя оставлять полумёртвый файл застарелой версии рядом с новой,
   * нельзя дублировать функции (`updateScheduleView` в двух вариантах).

Мы хотим ЧИСТЫЙ проект, без мусора и двойников.
Одно место правды на каждую вещь.

=================================
8. ЧТО ДЕЛАТЬ В НОВОМ ЧАТЕ
==========================

Когда ты запускаешь новый чат с ИИ:

1. Скопируй сюда весь этот документ (включая это описание).

2. Скажи что-то вроде: "это контекст проекта".

3. Дальше дай текущие версии файлов, которые сейчас важны для задачи.
   Пример:

   * index.html
   * css/styles.css
   * js/app.js
   * js/infra/telegramEnv.js
   * js/ui/events.js
   * js/ui/view-dashboard.js
   * js/ui/view-calendar.js
   * js/ui/view-schedule.js
   * js/data/repo.js
   * js/usecases/adjustTaskPercentForDate.js
   * js/usecases/toggleTaskDoneForDate.js
   * js/usecases/editTaskInline.js
   * js/usecases/resetToSchedule.js
   * js/usecases/addTaskToSchedule.js
   * js/usecases/editTaskInSchedule.js
   * js/usecases/deleteTaskFromSchedule.js
   * js/domain/entities.js

4. Когда просишь изменить поведение — чётко говори что нужно.
   Например:

   * "У задачи из разгрузки при клике ✎ не показывается плашка редактирования, почини"
   * "Календарь показывает NaN в шапке"
   * "Сделай так, чтобы Storage.init() нормально определял режим в Telegram 6.0"

5. Когда я присылаю patch.txt, ты применяешь его через свой apply-patch.cmd.
   Если после этого у тебя новая ошибка в консоли — присылай лог (включая стек).

=================================
9. КОРОТКИЙ TL;DR ДЛЯ ИИ В НОВОМ ЧАТЕ
=====================================

* Это фронтенд без бэкенда.
* Хранилище через наш Storage (cloud/local), обязательно `await Storage.init()` в app.js.
* repo.js = единственный способ читать/писать данные.
* У дня может быть override (planner.override.YYYY-MM-DD.v1) — снимок задач и прогресса на конкретную дату.
* override создаётся только при изменении, а не при простом просмотре.
* В dashboard есть:

  * обычные задачи дня,
  * блок "Разгрузка". Задачи из разгрузки сохраняют прогресс не в "сегодня", а в дне-дедлайне (предыдущем дне недели).
* При редактировании задачи из "Разгрузка" дашборд показывает плашку, а не форму.
* В "Расписании недели" дизейбл чекбокса разгрузки ставится на ДЕДЛАЙН-день (предыдущий день недели), а не на сам день задачи.
* Мы работаем через patch.txt (полные файлы).
* Новое правило: ИИ не вносит незапрошенные изменения в другие части кода, не переименовывает, не реорганизует архитектуру, не создаёт дубликатов логики, пока пользователь явно не скажет "да, делаем". Это важно.

Это всё. Если это прочитано и принято — можно продолжать разработку 😎
